---
layout:     post
title:      变量与数据类型
subtitle:   变量的执行环境、作用域以及各种数据类型
date:       2019-02-15
author:     MX
header-img: img/post-bg-js-version.jpg
catalog: true
tags:
    - JavaScript
---
# 变量
* ECMAScript 中定义变量使用 var 操作符，后跟一个变量名，变量可以用来保存任何类型的数据。变量未赋值时，值为undefined。
* 使用 var 操作符定义的变量将成为定义该变量所在定义域中的局部变量。也就是说，如果在函数中使用 var 定义一个变量，那么这个变量在函数退出后就会被销毁。
* 虽然省略 var 操作符可以定义全局变量，但是这样会造成变量难以维护。
* 一条语句定义多个变量（初始化或不初始化均可）时，用逗号分开即可。

# 数据类型
* ECMAScript中有5种基本数据类型（Undefined、Null、Boolean、Number、String）和一种复杂数据类型（Object）。Object本质上是由一组无序的名值对组成的。
* 基本类型值指的是简单的数据段，它们是按值访问的，因为可以操作保存在变量中的实际的值。
* 引用类型值指那些可能由多个值构成的对象，它们保存在内存中。而js不允许直接访问内存中的位置，因此，操作对象实际上是在操作对象的引用，所以，引用类型的值是按引用访问的。
* 我们不能给基本类型的值添加属性，只能给引用类型值动态地添加属性，以便将来使用
* 从一个变量向另一个变量复制基本类型的值，二者互不影响，而复制引用类型的值时，只是复制了一份指针，二者相互影响，因为两个指针实际上指向一个对象。函数的传参性质上和变量的复制相同。
* 引用数据类型：object、array、date、RegExp、function、基本包装类型（Boolean、number、string）、单体内置对象（global对象、math对象）
* 基本类型值和引用类型值具有以下特点：
	* 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
	* 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；
	* 引用类型的值是对象，保存在堆内存中；
	* 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；
	* 从一个变量到另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象；
	* 确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用 instanceof 操作符

## 执行环境和作用域
> 所有变量（包括基本类型和引用类型）都存在一个执行环境（也成为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结：

* 执行环境规定了变量或函数访问数据的权利。有全局执行环境（也称全局环境）和函数执行环境之分；
* 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链，作用域链是为了保证变量或函数的有序访问。
* 函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含(父）环境，乃至全局环境；
* 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；
* ECMAScritp中没有块级作用域，（语句中）使用var声明的变量会自动添加到最近的环境中。不适用var关键字，变量会添加到全局环境中。
* 变量的执行环境有助于确定应该何时释放内存。

## 检测数据类型
* typeof 操作符用来检测变量的数据类型。返回值有六种（未定义：undefined、布尔值：boolean、数值：number、字符串：string、对象或null：object、函数：function）。typeof 是一个操作符而不是一个函数，括号可有可无。
* 数据类型转换：

![数据类型转换](https://raw.githubusercontent.com/yinminxuan/yinminxuan.github.io/master/image/2019-03-15-change.jpg)
## 基本类型

### Undefined类型
检测 声明未赋值的变量、声明但赋值为 undefined 的变量、未声明的变量时，返回 undefined 值。但是 alert（）未声明的变量时，会报错 " 变量名 is not defined "。
### Null类型
null表示一个空对象指针，所以使用 typeof 操作符检测 null 值时会返回 " object " 。实际上，undefined 值时派生自 null 值的，所以它们的相等性检测返回的是 true。

	alert(null == undefined);	//true

只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。这样做不仅可以体现 null 作为空对象指针的惯性，而且也有助于进一步区分 null 和 undefined。

	if(car != null){
		//对 car 对象执行某些操作
	}

### Boolean类型
true 不一定等于 1 ，也不等于 True ，false 不一定等于 0 ，也不等于 False。Boolean 类型的值只有两个字面值：小写的 true 和 false。

任何数据类型调用 Boolean（）函数都会返回一个 Boolean 值。以下是转换规则
![Boolean()函数的转换规则](https://raw.githubusercontent.com/yinminxuan/yinminxuan.github.io/master/image/2019-03-15-boolean.jpg)

### Number类型
* 在进行算术计算时，所有八进制和十六进制表示的数值最终都会被转换成十进制数值。
* 保存浮点数值需要的内存空间是保存整数值的两倍，所以 ECMAScript 会把适合以整数值来保存的浮点数值存为整数值。
* 对于极大或极小的数值，使用科学记数法来表示。3.1415e7=31415000 / 3.1415e-7=0.00000031415 。ECMAScript 会将带有 6 个 0 以上的浮点数值转换为以 e 表示法表示的数值。
* 0.1+0.2=0.30000000000000004 。浮点数值运算时的精度问题。
* 数值范围 -Infinity（负无穷）小于 5e-324 小于1.7976931348623157e308 小于 Infinity（正无穷）。**使用 isFinite() 函数来判断一个数值是否位于最大和最小的数值之间，返回值为 boolean 值**
* 涉及 NaN 的操作都会返回 NaN ，NaN 与任何值都不相等。**使用 isNaN() 函数判断是否为数值，NaN 为 true，不是 NaN 为 false**。
* 数值转换：
	* **Number()** 可以将任何数据类型转换成数值；
	* **parseInt()** 弥补 Number() 转换字符串时的不合理，该函数按照数值模式来转换，能够识别各种整数格式。第二个参数表示要按照多少进制来转换。如果不指定会有冲突。它会忽略字符前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或者负号，会返回 NaN ，只有空字符串也会返回 NaN，不是 0 。
	* **parseFloat()** 解析字符串时，方式和 parseInt() 类似，区别是第一个小数点有效，同时会忽略前导的零。

### String类型
* 字符串可以由双引号（ " ）或单引号（ ' ）表示。
* 使用 \ 来转译字符。
* 改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新的字符串填充该变量。
* 转换为字符串：
	* **toString()**函数返回相应的字符串表现，但是 null 和 undefined 没有这个方法。
	* **String()**函数可以将任何类型的数值转换为字符串。

## 引用类型

### Object类型
引用类型的值（对象）是引用类型的一个实例。在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起，它们描述了一类对象所具有的属性和方法。

* Object 是ECMAScript中所有对象的基础类型。
* Object的每个实例都具有下列属性和方法：
	* constructor：保存着用于创建当前对象的函数。
	* hasOwnProperty（propertyName）：检测给定的属性在当前对象实例中是否存在。
	* isPrototypeOf（object）：检测传入的对象是否是当前对象的原型。
	* propertyIsEnumerable（propertyName）：检测给定的属性是否能用 for-in 来遍历。
	* toLocaleString（）：返回对象的字符串表示，该字符串与执行环境的地区对应。
	* toString（）：返回对象的字符串表示。
	* valueOf（）：返回对象的字符串、数值或布尔值表示。通常与 toString（）方法的返回值相同。
* 定义对象可以通过构造函数，也可以使用简写方式：对象字面量。
* 左花括号在这里表示表达式上下文的开始，如果出现在语句中，表示一个语句块的开始，为了兼容 IE 浏览器，所以在最后一个属性后面不能加逗号。
* 访问对象的属性可以使用点表示法和方括号表示法。在使用方括号语法时，要将访问的属性以字符串的形式放在方括号中，优点是可以使用变量来访问属性和属性名包含会导致语法错误的字符时如何访问属性，比如属性名使用了关键字、保留字，包含空格、包含非字母非数字时，就可以使用方括号表示法来访问它们。


### Array类型
* Array是数据的有序列表，它的每一项可以保存任何类型的数据。创建方法有构造函数和字面量两种。
* 读取和设置数组的值时，要使用方括号并提供相应的基于 0 的数字索引。如果设置某个值的索引超过了数组现有的项数，数组就会自动增加到该索引值加 1 的长度，那些未定义值的项值为 undefined。
* length 属性始终返回 0 或更大的值，可以通过设置这个属性来移除数组末尾的项或向数组中添加新项。
* [检测数组、安全的类型检测](http://www.cnblogs.com/kasmine/p/6428970.html)
* 转换方法：
	* valueOf（）方法返回数组本身。
	* toString（）方法返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。
	* toLocaleString（）方法也会创建一个数组值的以逗号分隔的字符串。不同的是，它会调用每一项的 toLocalString（）方法，而不是 toString（）方法。
	* join（）方法只接收一个参数，即用作分隔符的字符串，返回包含所有数组项的字符串。
* 栈方法：
	* pop（）方法从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。
	* push（）方法接收任意数量的参数，把它们添加到数组末尾，返回修改后数组的长度。
* 队列方法：
	* shift（）方法移除数组中的第一个项，减少数组的 length 值，然后返回移除的项。
	* unshift（）方法接收任意数量的参数，把它们添加到数组前端，返回修改后数组的长度。
* 重排序方法：
	* reverse（）方法会反转数组项的顺序。
	* sort（）方法会调用每个数组项的 toString（）方法，然后比较得到字符串。它可以接收一个比较函数作为参数，返回经过排序之后的数组。

`

	function compare(value1, value2){
		if(value1 < value2){
			return -1;
		} else if (value1 > value2){
			return 1;
		} else {
			return 0;
		}
	}
	//对于数值类型或者其 valueOf（）方法会返回数值类型的对象类型，可以使用下面的比较函数：
	fundtion compare(value1, value2){
		return value2 - value1;
	}
`

* 操作方法：会返回新数组。
	* concat（）方法接收一个或多个参数，将这些参数添加到数组末尾，返回一个新数组。如果参数中有数组，会合并。
	* slice（）方法接收一个或两个参数，即要返回项的起始位置和结束位置，返回一个新数组。一个参数为起始位置到数组末尾，两个参数为二者之间，左包右闭。
	* splice（）方法的参数:起始位置、要删除的项数、要插入的项一、要插入的项二...要插入的项 N。返回一个新数组，包含删除的项或空。
		* 删除：可以删除任意数量的项，只需指定两个参数：要删除的第一项的位置和要删除的项数。例如，splice（0,2)会删除前两项。
		* 插入：可以向指定位置插入任意数量的项，需提供三个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。
		* 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，需指定三个参数：起始位置、要删除的项和要插入的任意数量的项。插入的项不必与删除的项数相等。
* 位置方法：
	* indexOf（）方法接收两个参数，要查找的项和（可选的）表示查找起点的索引，以全等的方式从数组开头向后查找，返回要查找的项在数组中的位置或 -1。
	* lastIndexOf（）方法接收两个参数，要查找的项和（可选的）表示查找起点的索引，以全等的方式从数组末尾向前查找，返回要查找的项在数组中的位置或 -1。
* 迭代方法：会修改原数组。传入的函数会接收三个参数：item数组项的值、index该项在数组中的位置、array数组对象本身。
	* every（）对数组中的每一项运行传入的函数，如果该函数对每一项都返回 ture，则返回 true。
	* some（）对数组中的每一项运行传入的函数，如果该函数对任意一项返回 true，则返回 true。 
	* filter（）对数组中的每一项运行传入的函数，返回该函数会返回 true 的项数组成的数组。
	* forEach（）对数组中的每一项运行传入的函数，这个方法没有返回值。
	* map（）对数组中的每一项运行传入的函数，返回每次函数调用的结果组成的数组。
* 归并方法：传给这两个方法的函数接收 4 个参数：prev前一个值、cur当前值、index项的索引和array数组对象。
	* reduce（）接收两个参数，在每一项上调用的函数和（可选的）作为归并基础的初始值。从数组的第一项遍历到最后。
	* reduceRight（）接收两个参数，在每一项上调用的函数和（可选的）作为归并基础的初始值。从数组的最后一项遍历到第一项。

### Date类型
[简介](https://www.cnblogs.com/bobodeboke/p/6270777.html)、[详解](http://www.cnblogs.com/moqiutao/p/4875946.html)
### RegExp类型
[注意要点](https://segmentfault.com/a/1190000004002315)
### Function类型
* 通过函数可以封装任意多条语句，而且可以在任何地方，任何时候调用执行。
* 参数不限数量，不限数据类型。参数在内部使用一个数组来表示的，函数接收到的始终都是这个数组。在函数内可以使用 arguments 对象来访问这个参数数组。
* 返回值：无需指定返回值，因为函数可以在任何时候返回任何值。未指定返回值的的函数返回的是一个undefined值。
* 函数声明：使用 function 关键字来声明一个函数。
* 函数表达式：使用函数表达式定义函数时，没有必要使用函数名，通过变量名即可引用函数。
* 没有重载：同名函数后面的会覆盖前面的。
* 函数的调用表达式与关键字声明的函数没有先后顺序，但与使用函数定义表达式创建的函数有关，会报错，因为函数位于一个初始化语句中，而不是一个函数声明。函数声明提升时不会将其添加到执行环境中。 
* 在ECMAScript中函数名本身就是变量，所以函数也可以作为值来使用，可以把函数作为另一个函数的参数，也可以作为另一个函数的结果返回。
* 内部属性：
	* arguments 对象包含着传入函数的所有参数，该对象的 callee 属性指向拥有这个 arguments 对象的函数。
	* this 引用的是函数执行的环境对象。
	* caller属性中保存着当前函数的引用，如果是在全局作用域中调用当前函数，它的值为 null。

`

	function factorial (num){
		if (num <=1){
			return 1;
		} else {
			//return num * factorial(num-1);
			return num * arguments.callee(num-1);
			//这种写法不论引用函数时使用的是什么名字，都可以保证正常完成递归调用。
		}
	} 	

	function outer() {
		inner();
	}
	function inner() {
		//alert（inner.caller);
		alert(arguments.callee.caller);
	}
	outer();
	//会在警告框中显示outer（）函数的源代码。
`

* 函数属性和方法：
	* length属性表示函数希望接收的命名参数的个数。
	* prototype属性保存着所有实例方法。
	* apply（）、call（）
		* 这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。在不给函数传递参数的情况下，使用那个方法口可以。
		* applay（）方法接收两个参数，在其中运行函数的作用域和参数数组，数组可以是arguments对象，也可以是其他。
		* call（）方法第一个参数是 this 没有变化，其余参数需要直接传递给函数，逐个列出来。
	* bind（）方法会创建一个函数的实例，其 this 值会被绑定到传给 bind（） 函数的值。 
	* valueOf（）、toString（）、toLocaleString（）返回函数代码，格式因浏览器而异
* 递归：递归函数是在一个函数通过名字调用自身的情况下构成的。
* 闭包：闭包是指有权访问另一个函数作用域中的变量的函数。
### 基本包装类型
* 基本类型值不是对象，从逻辑上讲它们不应该有方法，为了实现直观的操作，后台会自动完成一系列的处理，从而变得跟对象一样。
	1. 创建基本类型的一个实例；
	2. 在实例上调用指定的方法；
	3. 销毁这个实例。
* 因基本包装类型对象独特的生存期，我们不能在运行时为基本类型添加属性和方法。
#### Boolean
* var falseObject = new Boolaen（false） / var falseValue = false；

#### Number
* toFixed（）方法会按照指定的小数位返回数值的字符串表示，参数为 2 时，表示显示 2 位小数。
* toPrecision（）返回以指数表示法（也称 e 表示法）表示的数值的字符串形式，参数同样为指定输出结果中的小数位数。

#### String
* length属性表示字符串中包含多个字符，空格也算一个字符，即使字符串中包含双字节字符（不是占一个字节的 ASCⅡ 字符），每个字符也仍然算一个字符。
* 字符方法：
	* charAt（）方法以单字符字符串的形式返回给定位置的那个字符，参数为索引。
	* charCodeAt（）方法返回的是字符编码。
*字符串操作方法： 
	* concat（）方法将一或多个字符串拼接起来，返回新的字符串。使用加号操作符在大多数情况下都比使用concat（）方法要简单易行。
	* slice（）接受一或两个参数，第一个指定字符串的开始位置，第二个表示子字符串到哪里结束。一个从指定位置到最后，两个左包右闭。
	* substr（）接受一或两个参数，第一个指定字符串的开始位置，第二个参数指定的是返回的字符个数。一个从指定位置到最后，两个返回指定个数。
	* substring（）接受一或两个参数，第一个指定字符串的开始位置，第二个表示子字符串到哪里结束。
* 字符串位置方法：
	* indexOf（）方法接收两个参数，要查找的字符串和（可选的）表示查找起点的索引，以全等的方式从字符串开头向后查找，返回给定字符串在字符串中的位置或 -1。
	* lastIndexOf（）方法接收两个参数，要查找的字符串和（可选的）表示查找起点的索引，以全等的方式从字符串末尾向前查找，返回给定字符串在字符串中的位置或 -1。
* trim（）方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。
	* trimLeft（）和 trimRight（）用于删除字符串开头和末尾的空格。
* 字符串大小写转换方法：
	* toLowerCase（）
	* toLocaleLowerCase（）
	* toUpperCase（）
	* toLocaleUpperCase（）
* 字符串的模式匹配方法：
	* match（）方法
	* search（）方法
	* replace（）方法
	* split（）方法
* localeCompare（）方法
* fromCharCode（）方法

### 单体内置对象
由ECMAScript 实现提供的、不依赖于宿主环境的对象，在程序执行之前就已经存在了，开发人员不必实例化对象。

#### Global 对象
* URI 编码方法
	* encodeURI（）
	* encodeURIComponent（）
	* decodeURI（）
	* decodeURIComponent（）
* eval（）方法
* Global 对象的属性
* window 对象

#### Math 对象
* Math 对象的属性
* min（）和 max（）方法
* 舍入方法
* random（）方法
* 其他方法


